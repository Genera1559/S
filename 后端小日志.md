只需要生成九个数独,不需要求解

进行需求分析

原型绘制

代码实现

> 使用并发技术生成九个数独
>
> 指定合适的代码规范进行测试
>
> 使用git进行版本控制

用户需求采用NABCD模型(500字)

> NABCD Need Approach Benefit Competitor Delivery

>需求:九宫格数独,但是由于Jason很暴躁,不想等串行,所以只能做成并行,而且由于Jason哥很聪明所以无需求解

> 做法:直接按照结果来做出数独,然后挖空提供给用户,但是结合不能串行且实现起来时间复杂度似乎必然很高,所以改为了随机出题然后交给计算机求解,有解则返回,无解继续随机

> 好处:可以保证可解性,同时提供了给出参考答案的可选项

> 竞争:

> 推广:

PSP表格

> Personal Software Process

| PSP             | 任务内容     | 计划完成需要的时间(min) | 实际完成需要的时间(min) |
| --------------- | ------------ | ----------------------- | ----------------------- |
| Planning        | 计划         | 60                      | 60                      |
| Estimate        | 预估         | 30                      | 30                      |
| Development     | 开发         | 1000                    | 1200                    |
| Analysis        | 需求分析     | 60                      | 90                      |
|                 | 原型绘制     | 40                      | 40                      |
| Design Spec     | 设计设计文档 | 30                      | 30                      |
| Design Review   | 设计复审     | 30                      | 30                      |
| Coding Standard | 代码规范     | 40                      | 10                      |
| Design          | 具体设计     | 60                      | 120                     |
| Coding          | 具体编码     | 500                     | 600                     |
| Code Review     | 代码复审     | 60                      | 60                      |
| Test            | 测试         | 40                      | 40                      |
|                 | 写博客       | 60                      | 60                      |
|                 | 总结         | 1010                    | 1370                    |

### 先去偷师一下数据结构

用来解题的算法

深度优先搜索

使用vector和随机数生成,虽然逻辑上看上去很慢,但是实际上并没有多慢

C++中的thread

设置环境变量：

```text
X_VCPKG_ASSET_SOURCES
```

值为：

```text
x-azurl,http://106.15.181.5/
```

实际上没有起多大作用,但是确实是有被代理掉,下次可以找一个更可靠的

无法解析的外部符号

通常是库目录有问题或者附加依赖项有问题

区别一下dll和lib的区别

外部包含目录就应该指定到json包

链接器中引用的应该是lib文件



C++下处理json

遇到报错dll文件出现异常通常都是内存溢出,空指针,索引错误之类的

json.h库不知道为什么总是会报奇怪的内存溢出错误,更改一下json对象的参数都会报错,无法理解

改为使用nlohmann/json之后一切迎刃而解,但是又有了新的问题,因为作业要求前端要为web或者app,app不是太懂,但是我认为大致的实现方法应该都是前端通过GET请求来获取后端的数据,或者直接用javascript写数独,那样应该体现不出结对开发的效果,之前用过springboot做过前后端交互,这次想要用C++,顺便体会一下为什么大家伙都在用java开发web.

那么问题就来了,九个数独,一次请求?还是九个数独,九次请求?

安装boost库遇到报错``Failed to build Boost.Build engine.
Please consult bootstrap.log for further diagnostics.``

确定自己的vc版本,并添加cl.exe到环境变量

然后再次遇到新报错

``fatal error C1034: stddef.h: 不包括路径集``

配置了一下INCLUDE系统变量

新报错``LINK : fatal error LNK1181: 无法打开输入文件“kernel32.lib”``

配置LIB系统变量

依旧报错``b2.exe : fatal error LNK1120: 74 个无法解析的外部命令``

才发现其实我一直在做的事情是cl编译,借此正好学习了编译程序的原理

之前用到json库的时候,遇到过类似的报错,通过修改库变量,链接器参数完成了环境的配置,这次应该要用更本质的东西来解决问题,

log文件中显示``找不到cpp文件``

cpp文件应该是boost里的文件,应该不是我环境配置的有问题,我感觉问题有点离谱所以重新找了个别的版本的boost

他居然什么都没报错的就一步一步的装好了

虽然过程有点曲折但是对于log文件的查看以及问题的排查还有编译,链接的过程有了些许认识

头文件只能声明函数不能写内容否则会出现重定义,说人话就是不能写{}

报错出现在源码的未定义错误实在是令人头疼,看又看不懂,问有不知道去哪问,但是AI倒是很懂,出现了几次都说是结构体传参问题

#### JavaScript

console.log()是输出的意思

出现了这样的问题:客户端向服务端发送多次get请求,得到同样的数据

我懵了,此时的项目已经脱离了文件,单纯只有json返回值,尝试了修改客户端的访问时间排除了是因为同时请求的问题,服务端也尝试了互斥锁,但是没有任何作用

无敌的AI给出了解释:

这段代码是一个基于Boost.Asio库实现的简单的TCP服务器，用于处理HTTP GET请求，并返回一个数独题目的JSON数据。

在主函数中，通过创建一个`tcp::acceptor`对象并指定监听的端口号，然后进入一个无限循环中。每当接收到一个连接请求时，就会创建一个新的线程来处理该请求。处理请求的函数`thread_fun`首先读取请求消息，并判断请求方法是否为GET。如果是GET请求，则构建响应头，读取数独题目的JSON数据，并构建完整的响应消息。最后将响应消息通过`boost::asio::write`函数发送回客户端。

根据你提供的代码，两次GET请求得到相同的结果可能是因为在每次请求中生成的数独题目都是相同的。对于生成数独题目的方法`generateSudoku`和`generateSudokuHelper`，使用了随机乱序的数字填充格子，但是随机种子的初始化是通过`srand(static_cast<unsigned int>(time(0)))`进行的，而在两次请求之间的时间间隔很短，导致随机种子没有变化，从而生成了相同的数独题目。可以考虑在每次生成数独题目之前重新设置随机种子，例如可以使用`std::random_device`生成一个真正的随机数作为种子，或者使用其他随机数生成器库（例如Boost.Random）来生成随机数。

随机数种子的问题,没想到啊没想到

#### git的使用

``git init``在目录下初始化仓库

``git remote add 仓库名 仓库获取的链接``

``git remote -v``

``git add .``添加本地目录到缓存区

``git commit`` 将工作区提交到版本库

``git status``查看状态

``git branch main`` 本地建立main分支

``git branch -M main``设置main分支

``git push Suduku main:main``push其实是同步双边仓库

``git pull``拉取当前仓库

``git branch --set-upstream-to=Suduku/<branch> main`` 同步本地分支与远程分支

#### 后端用了啥

并发性算法

> 在具体的实现上因为方案的变更使用了多种方法suduku_get_json.cpp中被注释掉的的main函数实现的是利用thread库多线程调用函数同时生成9个数独,在后续确定前端是网页之后放弃了这个看上去笨笨的方法,现版本是在网络监听上使用了多线程,并且通过设置更加可靠的随机数种子,严格控制局部变量的使用而非全局变量,以及互斥锁(最后没用上)来防止线程间数据的错乱

数独可解性

> 因为具体的实现上是后端生成一个数独答案再交给前端进行蒙版,所以数独题目是一定可解的

代码规范

> 前后端只通过发送请求来进行沟通,所以代码上属于是各写各的,只在业务逻辑上进行了对接

## 第二次

并发生成可解

并发求解

第一次作业的做法是在前端进行蒙版

所以最简单的做法就是在前端将答案进行缓存,从而实现求解

但总感觉上述的做法有问题

但是如果不按上述做法这么做,就要涉及数独是否有唯一解的问题,但这个问题似乎没有很好的解决方法

异步操作(没搞明白)和多线程

最后封装了一个post请求来求解任何前端发送来的数独题目

请求体是包含对象的json而非数字所以需要处理

但是根据控制台打印出来的请求体是不完整的,缓冲区的大小似乎不够塞不下缓冲区

散个步再来

``` c++
//返回的是第一个\r\n\r\n的下标
size_t pos = reqstr.find("\r\n\r\n");
```

所以只能一层层排查,首先是streambuf,似乎问题不在这

然后是第二层

![image-20231004215137777](D:\Database\MarkdownImage\image-20231004215137777.png)

初始化的时候设定了更大的max_size_但是不知道为什么buffer还是只有512

```c++
//初始化最大缓冲区
boost::asio::streambuf request_buffer(1024);
//增加可写空间
    request_buffer.prepare(1024);
    boost::asio::read_until(socket, request_buffer, "\r\n");

```

换行符是实实在在的占据了传输空间的

可惜我还不知道怎么优化
